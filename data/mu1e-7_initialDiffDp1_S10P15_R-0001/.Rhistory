# If run with an sbatch pipeline take arguments from there. Otherwise those specified here.
if (length(commandArgs(trailingOnly=TRUE))==0) {
# args <- c('mu5e-7_initialDiffDp1_S50P15_R-13997','5*10^-7','15',F, F)
args <- c('mu1e-7_initialDiffDp1_S10P15_R-0001','1*10^-7','15',F, T)
} else {
args <- commandArgs(trailingOnly=TRUE)
}
base_name <- args[1]
mu <- eval(parse(text = args[2]))
protospacer_len <- eval(parse(text = args[3]))
make_plots <- as.logical(args[4])
if(on_Midway()){system('module load gcc/6.1')}
if(!on_Midway()){setwd(paste('data/',base_name,sep=''))}
base_name
dir.create('figures')
library(ggtree)
library(ape)
library(treeio)
library(igraph)
library(tidyverse)
library(magrittr)
library(bipartite)
library(cowplot)
library(grid)
library(infomapecology)
if(check_infomap()==F){install_infomap()} # Install infomap
# Functions ---------------------------------------------------------------
prep.packages <- function(package.list, verbose=T) {
loaded = package.list %in% .packages()
if ( all(loaded) ) return(invisible())
package.list = package.list[!loaded]
installed = package.list %in% .packages(TRUE)
if ( !all(installed) ) install.packages(package.list[!installed], repos="http://cran.rstudio.com/")
for ( p in package.list ){
print(paste("Loading package:",p))
if (verbose){
library(p,character.only=TRUE)
} else {
suppressMessages(library(p,character.only=TRUE))
}
}
}
returnnull <- function(x) if (is.null(x)){'none'} else {x}
notify <- function(x){
print(paste('[',Sys.time(),'] ',x,sep=''))
}
record_data <- function(x){
notify(paste('Recording ',deparse(substitute(x)),sep=''))
write_csv(x, paste(base_name,'_',deparse(substitute(x)),'.csv',sep=''), col_names = T)
}
make_name <- function(x,hr){
hr_str <- str_pad(hr, width = 4, side = 'left', pad = '0')
paste('data/',x,'_',hr_str,'.csv',sep='')
}
make_png <- function(p, method='ggsave'){
if (method=='ggsave'){
ggplot2::ggsave(paste('figures/',base_name,'_',deparse(substitute(p)),'.png',sep=''), p, device = 'png', width = 32, height = 18, units = 'cm', dpi = 200)
} else {
png(paste('figures/',base_name,'_',deparse(substitute(p)),'.png',sep=''),1920,1080,res=150)
print(p)
dev.off()
}
}
make_svg <- function(p){
svg(paste('figures/',base_name,'_',deparse(substitute(p)),'.svg',sep=''),12.8,8)
print(p)
dev.off()
}
make_png_svg <- function(p){
make_png(p)
make_svg(p)
}
standard_plot <- function(p){
p+scale_x_continuous(breaks=label_seq)+
geom_vline(xintercept=BDRs$start, col='#27AE60',size=1.2)+
geom_vline(xintercept=VDRs$start, col='purple',size=1.2)+
labs(x='Time')
}
gg_color_hue <- function(n, hue_min = 10, hue_max = 280, tune1 = 62, tune2 = 100) {
hues = seq(hue_min, hue_max, length=n+1)
hcl(h=hues, l=tune1, c=tune2)[1:n]
}
list_to_matrix <- function(l, directed=F, bipartite=T){
# Only deal with first 3 columns.
g <- graph.data.frame(l,directed = directed)
if(bipartite){
V(g)$type <- V(g)$name %in% as.data.frame(l)[,1] # As.data.frame is necessary because if l is a tibble then l[,1] does not work
output_mat <- as_incidence_matrix(g, names = T, attr = 'w', sparse = F)
} else {
output_mat <- as_adjacency_matrix(g, names = T, sparse = F, attr = 'w')
}
# print(dim(output_mat))
# if(any(rowSums(output_mat)==0)){stop('One or more rows sum to 0')}
# if(any(colSums(output_mat)==0)){stop('One or more columns sum to 0')}
return(output_mat)
}
create_networks_hr <- function(virus_data,bacteria_data,hr){
virus_data_hr <- virus_data %>% filter(timesOfRecord==hr)
bacteria_data_hr <- bacteria_data %>% filter(timesOfRecord==hr)
virus_abund_hr <- virus_data_hr %>% select(label, density) %>% rename(V_ID=label) %>% mutate(V_ID=paste('V_',str_pad(V_ID, 4, 'left', '0'),sep=''))
bacteria_abund_hr <- bacteria_data_hr %>% select(label, density) %>% rename(B_ID=label) %>% mutate(B_ID=paste('B_',str_pad(B_ID, 4, 'left', '0'),sep=''))
# Create networks in a list form
## Virus-protospacer network
virus_ps_hr_list <- virus_data_hr %>% select(-time, -timesOfRecord, -density) %>%
gather(key='PSidx', value='value', -label) %>%
rename(V_ID=label, PS=value) %>%
arrange(V_ID,PS) %>%
mutate(w=1) %>%
mutate(V_ID=paste('V_',str_pad(V_ID, 4, 'left', '0'),sep='')) %>%
mutate(PS=paste('P_',str_pad(PS, 4, 'left', '0'),sep='')) %>%
select(V_ID,PS,w,PSidx)
## Bacteria-spacer network
bacteria_sp_hr_list <- bacteria_data_hr %>%
select(-time, -timesOfRecord, -density) %>%
gather(key='SPidx', value='value', -label) %>%
filter(value!=-1) %>%
rename(B_ID=label, SP=value) %>%
arrange(B_ID,SP) %>%
mutate(w=1) %>%
# mutate(w=ifelse(SP==-1,0,1)) %>%
mutate(B_ID=paste('B_',str_pad(B_ID, 4, 'left', '0'),sep='')) %>%
mutate(SP=paste('P_',str_pad(SP, 4, 'left', '0'),sep='')) %>%
select(B_ID,SP,w,SPidx)
# Bacteria without spacers: This is needed for NEUTRAL SCENARIOS in which
# interactions are not related to spacer-protospacer acquisition. So bacteria
# can actually survive without acquiting protospacers.
bacteria_no_sp <- bacteria_data_hr %>%
select(-time, -timesOfRecord, -density) %>%
gather(key='SPidx', value='value', -label) %>%
filter(value==-1) %>%
group_by(label) %>%
summarise(no_spacers=n()) %>% filter(no_spacers==spacer_len) %>%
rename(B_ID=label) %>%
mutate(B_ID=paste('B_',str_pad(B_ID, 4, 'left', '0'),sep=''))
# Add to the bacteria-spacer network those bacteria without spacers.
suppressWarnings(
bacteria_sp_hr_list <- bind_rows(bacteria_sp_hr_list,
as.tibble(expand.grid(B_ID=bacteria_no_sp$B_ID, SP=unique(bacteria_sp_hr_list$SP), w=0)))
)
## Immunity network as a list
x <- virus_ps_hr_list %>% select(V_ID, PS)
y <- bacteria_sp_hr_list %>%
filter(w!=0) %>% # MUST include only the interactions usign filter(w!=0), otherwise the immunity network will have false edges that should not exist.
select(B_ID, SP)
immunity_list <- x %>% inner_join(y, by = c('PS'='SP')) %>%
arrange(B_ID, V_ID) %>%
group_by(V_ID, B_ID) %>% count() %>%
rename(w=n)
# Define nodes in the system
viruses_hr <- sort(unique(virus_abund_hr$V_ID))
bacteria_hr <- sort(unique(bacteria_abund_hr$B_ID))
spacers_hr <- sort(union(bacteria_sp_hr_list$SP, virus_ps_hr_list$PS))
nodes <- tibble(nodeID=1:(length(viruses_hr)+length(bacteria_hr)+length(spacers_hr)),
nodeName=c(viruses_hr, bacteria_hr, spacers_hr),
type=c(rep(1,length(viruses_hr)), rep(2,length(bacteria_hr)), rep(3,length(spacers_hr)))
)
nodes$type <- as.integer(nodes$type)
# Check networks
if (nrow(bacteria_sp_hr_list)==0) {bacteria_sp_hr_list <- NULL}
if (nrow(immunity_list)==0) {immunity_list <- NULL}
## Infection network
# To get this we first need to create the immunity nertwork as a matrix
if (!is.null(immunity_list)){
immunity_matrix <- list_to_matrix(immunity_list) # transform to a matrix format
} else {
immunity_matrix <- matrix(0, nrow=length(bacteria_hr), ncol=length(viruses_hr), dimnames = list(bacteria_hr, viruses_hr))
}
# Add all the nodes which were not included in the list because they have degree of zero
# missing_bacteria <- setdiff(unique(bacteria_sp_hr_list$B_ID),rownames(immunity_matrix))
# immunity_matrix <- rbind(immunity_matrix, matrix(0,
#                                                    ncol = ncol(immunity_matrix),
#                                                    nrow = length(missing_bacteria),
#                                                    dimnames = list(missing_bacteria, colnames(immunity_matrix))))
#
infection_matrix <- 1*(immunity_matrix==0) # Binary infection network is the "negative (photography-wise)" of the immunity network
if (any(infection_matrix==1)){ # If there is at least one non-zero interaction in the infection network
N_T <- sum(bacteria_abund_hr$density)
# This will produce a matrix with values: (N_i*V_j)/N_T
A <- crossprod(matrix(bacteria_abund_hr$density, nrow=1,
ncol=length(bacteria_abund_hr$density),
dimnames=list(NULL, bacteria_abund_hr$B_ID)),
matrix(virus_abund_hr$density,
nrow=1,ncol=length(virus_abund_hr$density)                        ,
dimnames=list(NULL, virus_abund_hr$V_ID)))
A <- A/N_T
# This will remove all cells that are 0.
A <- A[rownames(infection_matrix),colnames(infection_matrix)]
infection_matrix <- infection_matrix*A
# Transform the infection network to a list
g <- graph.incidence(t(infection_matrix), directed = F, weighted = T) # Need to transpose so the "from" would be viruses and the "to" would be bacteria
infection_list <- as.tibble(igraph::as_data_frame(g, what = 'edges'))
names(infection_list) <- c('V_ID', 'B_ID', 'w')
} else { # All interactions are 0
infection_list <- NULL
}
# Calculate the effective mutation matrix. These lines here save a double for loop
# and selecting bacteria and virus abundances at each step.
# First produce a matrix with N_i*V_j values:
A <- crossprod(matrix(bacteria_abund_hr$density, nrow=1,
ncol=length(bacteria_abund_hr$density),
dimnames=list(NULL, bacteria_abund_hr$B_ID)),
matrix(virus_abund_hr$density,
nrow=1,ncol=length(virus_abund_hr$density)                        ,
dimnames=list(NULL, virus_abund_hr$V_ID)))
A <- A[rownames(immunity_matrix),colnames(immunity_matrix)]
M0 <- 1*(immunity_matrix==0)
M0 <- M0*A*beta*mu*phi*(1-q) # This is from Childs et al 2012 Suppl Info, page 4. The multiplication by M0 thakes only the no matches
M1 <- 1*(immunity_matrix!=0)
M1 <- M1*A*beta*mu*phi*p # This is from Childs et al 2012 Suppl Info, page 4. The multiplication by M1 thakes only the  matches
mutation_matrix <- M0+M1
return(list(hr=hr,
virus_ps_list=virus_ps_hr_list,
bacteria_sp_list=bacteria_sp_hr_list,
immunity_list=immunity_list,
immunity_matrix=immunity_matrix,
infection_list=infection_list,
infection_matrix=infection_matrix,
mutation_matrix=mutation_matrix,
bacteria_no_sp=bacteria_no_sp,
virus_abund_hr=virus_abund_hr,
bacteria_abund_hr=bacteria_abund_hr,
nodes=nodes
))
}
get_regimes <- function (phage_time_series, d2_threshold=0.001, do_smoothing = T, make_plots=F) {
if (do_smoothing){print('Finding regimes with smoothing...')} else {print('Finding regimes without smoothing...')}
# Need to use the relative abundance of phages, because the total abundaces
# create huge numbers in the derivatives.
x <- phage_time_series %>%
group_by(timesOfRecord) %>%
summarise(a=sum(Pdensity)) %>%
rename(time=timesOfRecord) %>%
mutate(rel_abund=a/max(a, na.rm = T))
# Find 1st and 2nd derivatives of the time series
d1 <- diff(x$rel_abund)/diff(x$time)
d1_df <- tibble(time=1:length(d1), d1=d1)
d2 <- diff(d1_df$d1)/diff(d1_df$time)
d2_df <- tibble(time=1:length(d2), d2=d2)
# Define time series points as regimes. A point is defined in a regime if its 2nd derivative is lower than a threshold, d2_threshold
suppressMessages(
regimes <- x %>% left_join(d1_df) %>% left_join(d2_df) %>%
mutate(regime=ifelse(abs(d2)<=d2_threshold,'BDR','VDR'))
)
# Find sequences of regimes/no regimes.
regime_seq <- rle(regimes$regime)
regime_seq <- tibble(len=regime_seq$lengths, regime=regime_seq$values) # len is the length of the sequence
# This allows to see points where dynamics switch from regimes to no regimes
regime_seq$switch=cumsum(regime_seq$len) # cumsum gives the point in the time series
# Smoothing eliminates small blips where there is a few points of 'VDR'
# surrounded by many 'BDR'. This threshold is decided by the distribution of
# the lengths of no regime sequences. Sequences with length smaller than that
# threshold are defined as yes.
if (do_smoothing){
smoothing_threshold <- quantile(subset(regime_seq, regime=='VDR')$len, 0.75)
smoothing <- subset(regime_seq, len<=smoothing_threshold & regime=='VDR') %>% mutate(start=switch-len)
# smoothing$start[1] <- 1
for (i in 1:nrow(smoothing)){
# print(smoothing$start[i]:smoothing$switch[i])
regimes$regime[smoothing$start[i]:smoothing$switch[i]] <- 'BDR'
}
# After smoothing need to define regime sequences again
regime_seq <- rle(regimes$regime)
regime_seq <- tibble(len=regime_seq$lengths, regime=regime_seq$values)
regime_seq$switch=cumsum(regime_seq$len)
}
# To be a regime, a sequences has to be larger than the largest no-regime section,
# which is the virus outbreak with the largest duration.
max_virus_cycle <- max(subset(regime_seq, regime=='VDR')$len)
regime_end <- which(regime_seq$len>max_virus_cycle)
regime_start <- which(regime_seq$len>max_virus_cycle)-1
regime_end <- regime_seq[regime_end,]$switch
regime_start <- regime_seq[regime_start,]$switch
if (length(regime_start)<length(regime_end)){
regime_end <- regime_end[-1]
}
regimes_df <- rbind(
tibble(start=1, end=regime_start[1]-1, regime_type='VDR'), # Add the first no regime period
tibble(start=regime_start, end=regime_end, regime_type='BDR'),
tibble(start=regime_end+1, end=c(regime_start-1, stop_time)[-1], regime_type='VDR')
)
regimes_df$duration=regimes_df$end-regimes_df$start
regimes_df %<>% arrange(start)
# Plot some diagnostics
if (make_plots){
plt_diagnostics <-
regimes %>%
gather(key='key', value='value', -time, -regime) %>%
mutate(key=factor(key,levels = c('a','rel_abund','d1','d2'))) %>%
ggplot()+
geom_line(aes(time, value))+
geom_point(aes(time, value, color=regime), size=0.5)+
scale_color_manual(values = c('#27AE60','purple'))+
scale_x_continuous(breaks = seq(0,max(x$time),500))+
# scale_x_continuous(limits=c(800,1000))+
facet_wrap(~key, scales='free', labeller = as_labeller(c(`a` = "Virus abundance",
`d1` = "First derivative",
`d2` = "Second derivative",
`rel_abund` = "Virus relative abundance")))+
geom_vline(xintercept=regime_start, col='#27AE60')+
geom_vline(xintercept=regime_end, col='purple')+
theme(legend.position = 'none')+labs(x='Time')
} else {
plt_diagnostics <- NULL
}
return(list(regimes_df=regimes_df,
plt_diagnostics=plt_diagnostics))
}
print_pattern <- function(parent, child, parent_death, child_birth, child_death, node, i){
sprintf("(%s:%f, %s:%f)%s",
parent, parent_death-child_birth,
child, child_death-child_birth,
paste(node, i , sep = "_"))
}
nodes_dataframe_to_one_root <- function(nodes, parent, children, parent_death) {
for(i in 1:nrow(children)) {
newChildren <- nodes %>% filter(parent_id == children$id[i]) %>% arrange(desc(creation_time))
if (i == 1) {
tempParent<-parent
parent_death <- parent_death
}else{
tempParent<-out
parent_death<-children$creation_time[i-1]
}
if (nrow(newChildren) > 0) {
child <- nodes_dataframe_to_one_root(nodes, children$id[i], newChildren, children$death[i])
child_birth <- children$creation_time[i]
child_death <- newChildren$creation_time[nrow(newChildren)]
}else{
child <- children$id[i]
child_birth <- children$creation_time[i]
child_death <- children$death[i]
}
#print(list(tempParent, child, parent_death, child_birth, child_death))
out<-print_pattern(tempParent, child, parent_death, child_birth, child_death, parent, nrow(children)-i)
}
return(out)
}
nodes_dataframe_to_newick <- function(nodes) {
root <- nodes %>% filter(is.na(parent_id))
stopifnot(nrow(root) == 1)
children <- nodes %>% filter(parent_id == root$id) %>% arrange(desc(creation_time))
head(children)
out<-nodes_dataframe_to_one_root(nodes, root$id[1], children, root$death[1])
return(paste(out,  ":", children$creation_time[nrow(children)] - root$creation_time[1], ";",sep = ""))
}
# Function to test for phylogenetic signal in modules
test_PD_modules<- function(tree, module_object, node_start_letter){
# Phylogenetic signal analysis
D <- ape::cophenetic.phylo(tree) # Phyloegentic distance
D <- matrix_to_list_unipartite(D, directed = T) # Use directed to make sure that the from column has all the nodes (need it for joining later)
D <- D$edge_list
# Difference between tree and matrix
nodes_in_modules <- module_object$modules %>%
filter(str_starts(node_name, node_start_letter)) %>%
distinct(node_name) %>%
mutate(node_name=str_replace_all(node_name, pattern = '\\.', ''))
nodes_in_modules <- nodes_in_modules$node_name
nodes_in_tree <- tree$tip.label
# print(setdiff(nodes_in_modules, nodes_in_tree)) # In modules but not in tree
# print(setdiff(nodes_in_tree, nodes_in_modules)) # In tree but not in modules
# Overlapping nodes:
overlapping <- intersect(nodes_in_tree, nodes_in_modules)
# Observed modules
M_obs <- module_object$modules %>%
filter(str_starts(node_name, node_start_letter)) %>%
mutate(node_name=str_replace_all(node_name, pattern = '\\.', '')) %>%
filter(node_name %in% overlapping) %>%
rename(m=module_level1) %>%
select(node_name, m)
#Mean PDistance between hosts within modules
D_obs <- M_obs %>%
inner_join(D, by=c('node_name'='from')) %>% # join PD distances
rename(d=weight) %>%
arrange(m, node_name) %>%
group_by(m) %>% # Per module
filter(to %in% node_name) %>% #Host pairs within a module
summarise(d_mean=mean(d), mod_size=n())
D_obs_mean <- mean(D_obs$d_mean)
# print('Observed network:')
# print(D_obs)
#Shuffle to create permuted modules of the same size,
#and recalculate the meand PD within modules. The shuffling permutes the ID of the strains.
D_perm <- NULL
nperm <- 500
for (i in 1:nperm){
# print(i)
D_perm %<>% bind_rows(
M_obs %>%
mutate(node_name=sample(node_name, replace = F)) %>%
inner_join(D, by=c('node_name'='from')) %>% # join PD distances
rename(d=weight) %>%
arrange(m, node_name) %>%
group_by(m) %>% # Per module
filter(to %in% node_name) %>% #Host pairs within a module
summarise(d_mean=mean(d)) %>% # Calculate mean PD within modules
mutate(run=i)
)
}
# Null hypothesis is that the permuted distance is smaller than the observed for
# each module (i.e., no signal). If we reject this hypothesis then there is
# phylogenetic signal because the observed PD beteween hosts within each module
# would be smaller than expected by chance (closely related hosts share a module).
# Plot the means
plt_across_modules <-
D_perm %>% group_by(run) %>%
summarise(D_perm_mean=mean(d_mean)) %>%
ggplot(aes(x=D_perm_mean))+geom_histogram()+geom_vline(xintercept = D_obs_mean)
result_across_moduels <-
D_perm %>% group_by(run) %>%
summarise(D_perm=mean(d_mean)) %>%
mutate(test=D_perm<D_obs_mean) %>%
summarise(pvalue=sum(test)/nperm) %>%
mutate(res=ifelse(pvalue<0.05,'Signal','No signal'))
# This can also be tested per module
plt_within_modules <-
D_perm %>%
full_join(D_obs, by='m') %>%
rename(d_perm=d_mean.x, d_obs=d_mean.y) %>%
ggplot(aes(x=d_perm))+
geom_histogram()+
facet_wrap(~m)+
geom_vline(data = D_obs, aes(xintercept = d_mean))
result_within_moduels <-
D_perm %>%
full_join(D_obs, by='m') %>%
rename(d_perm=d_mean.x, d_obs=d_mean.y) %>%
mutate(test=d_perm<d_obs) %>%
group_by(m) %>%
summarise(pvalue=sum(test)/nperm) %>%
mutate(Signif=ifelse(pvalue<0.05,'Signal','No signal'),
Signif_Bonferroni=ifelse(pvalue<0.05/nrow(D_obs),'Signal','No signal')) # Need to divide by number of modules for Bonferroni correction
out <- list(D_obs=D_obs,
D_obs_mean=D_obs_mean,
plt_across_modules=plt_across_modules,
plt_within_modules=plt_within_modules,
result_across_moduels=result_across_moduels,
result_within_moduels=result_within_moduels,
nodes_in_modules=nodes_in_modules,
nodes_in_tree=nodes_in_tree,
overlapping=overlapping)
return(out)
}
virus_data <- read_delim(paste(base_name,'_data-phage.txt',sep=''), delim=' ', col_names = T)
bacteria_data <- read_delim(paste(base_name,'_data-bact.txt',sep=''), delim=' ', col_names = T)
bacteria_abundance <- read_delim(paste(base_name,'_Bacteria-abundance.txt',sep=''), delim = ' ')
phage_abundance <- read_delim(paste(base_name,'_Phage-abundance.txt',sep=''), delim = ' ')
stop_time <- min(max(virus_data$timesOfRecord), max(phage_abundance$timesOfRecord))
hr_seq <- seq(1, stop_time, 1)
hr_seq
hr_seq=1:1000
print(paste('-------- Working simulation:',base_name,' | stop time: ',stop_time,' | mu: ',mu,' | protospacers: ', protospacer_len,' | make plots: ',make_plots,'---------'))
virus_data %<>% filter(timesOfRecord<=stop_time)
bacteria_data %<>% filter(timesOfRecord<=stop_time)
bacteria_abundance %<>% filter(timesOfRecord<=stop_time)
phage_abundance %<>% filter(timesOfRecord<=stop_time)
regimes_df <- get_regimes(phage_time_series = phage_abundance, do_smoothing = T)$regimes_df
if (regimes_df[nrow(regimes_df),]$duration==1){regimes_df <- regimes_df[-nrow(regimes_df),]} # remove the end of simulation spurious effect
record_data(regimes_df)
BDRs <- subset(regimes_df, regime_type=='BDR')
VDRs <- subset(regimes_df, regime_type=='VDR')
# Vectors with the time points of VDRs and BDRs
VDR_hrs <- unlist(apply(VDRs, MARGIN = 1, FUN = function(x) seq(x[1],x[2])))
BDR_hrs <- unlist(apply(BDRs, MARGIN = 1, FUN = function(x) seq(x[1],x[2])))
BDRs
regimes_df
VDRs
# This is for the x axis labels when plotting
label_seq <- pretty(hr_seq, n=10)
label_seq <- subset(label_seq, label_seq<stop_time)
regimes_seq <- tibble(hr=c(VDR_hrs,BDR_hrs), regime_type=c(rep('VDR',length(VDR_hrs)),rep('BDR',length(BDR_hrs)))) %>% arrange(hr)
record_data(regimes_seq)
regimes_seq
# bacteria / phage diversity ----------------------------------------------
notify('Generating abundance profile plots...')
dom_strains_num <- 100
cols <- c('gray50',gg_color_hue(dom_strains_num))
bacteria_abundance
bacteria_abundance %>%
group_by(label) %>%
summarise(mean_abund=mean(Bdensity))
dominant_strains <- bacteria_abundance %>%
group_by(label) %>%
summarise(mean_abund=mean(Bdensity)) %>%
top_n(n=dom_strains_num, wt = mean_abund) %>%
arrange(label) %>%
mutate(dominant=T)
dom <- bacteria_abundance %>%
filter(label%in%dominant_strains$label) %>%
select(timesOfRecord, Bdensity, label)
non_dom <- bacteria_abundance %>%
filter(!label%in%dominant_strains$label) %>%
group_by(timesOfRecord) %>% summarise(Bdensity=sum(Bdensity)) %>%
mutate(label='0')
to_plot <- rbind(dom,non_dom)
to_plot$label <- factor(to_plot$label, levels=sort(as.numeric(unique(to_plot$label))))
plt_bact_abund <-
standard_plot(
ggplot(to_plot, aes(x=timesOfRecord,y=Bdensity/10^5, fill=label))+
geom_area(stat="identity", color='black', size=0.2)+
scale_fill_manual(values = cols)+
labs(y='Bact. abund. (*10^5)')+
theme(legend.position = 'none')+
geom_hline(yintercept = 10^5.5/10^5, linetype='dashed', size=0.4)
)
plt_bact_abund
# bacteria_abundance %>% ggplot(aes(x=Bdensity))+geom_density()
dominant_strains <- phage_abundance %>%
group_by(label) %>%
summarise(mean_abund=mean(Pdensity)) %>%
top_n(n=dom_strains_num, wt = mean_abund) %>%
arrange(label) %>%
mutate(dominant=T)
